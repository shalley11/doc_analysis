import base64
import requests
import concurrent.futures
from typing import List, Tuple

from doc_analysis.config import (
    OLLAMA_URL,
    VISION_MODEL_POC,
    VISION_BATCH_SIZE,
    VISION_TIMEOUT
)
from doc_analysis.vision.prompts import table_image_prompt, image_prompt
from doc_analysis.logging_config import get_worker_logger

logger = get_worker_logger()


def batch_vision(prompts):
    """Process text-based prompts with vision model."""
    outputs = []
    for p in prompts:
        r = requests.post(
            OLLAMA_URL,
            json={"model": VISION_MODEL_POC, "prompt": p, "stream": False},
            timeout=180
        )
        outputs.append(r.json()["response"])
    return outputs


def _encode_image_base64(image_path: str) -> str:
    """Encode image file to base64 string."""
    with open(image_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")


def generate_table_summary(image_path: str) -> str:
    """
    Generate summary for a table image using vision model.

    Args:
        image_path: Path to the table image file

    Returns:
        Summary text generated by vision model
    """
    try:
        image_b64 = _encode_image_base64(image_path)
        prompt = table_image_prompt()

        response = requests.post(
            OLLAMA_URL,
            json={
                "model": VISION_MODEL_POC,
                "prompt": prompt,
                "images": [image_b64],
                "stream": False
            },
            timeout=VISION_TIMEOUT
        )

        if response.status_code == 200:
            return response.json().get("response", "")
        else:
            logger.error(f"Vision model error: {response.status_code}")
            return ""
    except Exception as e:
        logger.error(f"Failed to generate table summary: {e}")
        return ""


def generate_image_summary(image_path: str) -> str:
    """
    Generate summary for a document image using vision model.

    Args:
        image_path: Path to the image file

    Returns:
        Summary text generated by vision model
    """
    try:
        image_b64 = _encode_image_base64(image_path)
        prompt = image_prompt()

        response = requests.post(
            OLLAMA_URL,
            json={
                "model": VISION_MODEL_POC,
                "prompt": prompt,
                "images": [image_b64],
                "stream": False
            },
            timeout=VISION_TIMEOUT
        )

        if response.status_code == 200:
            return response.json().get("response", "")
        else:
            logger.error(f"Vision model error for image: {response.status_code}")
            return ""
    except Exception as e:
        logger.error(f"Failed to generate image summary: {e}")
        return ""


def _process_single_table(args: Tuple[int, str]) -> Tuple[int, str]:
    """
    Process a single table image and return index with summary.
    Used for parallel processing.
    """
    idx, image_path = args
    if image_path:
        summary = generate_table_summary(image_path)
        return (idx, summary)
    return (idx, "")


def _process_single_image(args: Tuple[int, str]) -> Tuple[int, str]:
    """
    Process a single image and return index with summary.
    Used for parallel processing.
    """
    idx, image_path = args
    if image_path:
        summary = generate_image_summary(image_path)
        return (idx, summary)
    return (idx, "")


def batch_table_summaries_parallel(image_paths_with_indices: List[Tuple[int, str]]) -> dict:
    """
    Generate summaries for multiple table images in parallel.

    Args:
        image_paths_with_indices: List of (chunk_index, image_path) tuples

    Returns:
        Dict mapping chunk_index to summary text
    """
    if not image_paths_with_indices:
        return {}

    summaries = {}
    total = len(image_paths_with_indices)

    logger.info(f"Processing {total} table images in parallel (max_workers={VISION_BATCH_SIZE})")

    with concurrent.futures.ThreadPoolExecutor(max_workers=VISION_BATCH_SIZE) as executor:
        future_to_idx = {
            executor.submit(_process_single_table, item): item[0]
            for item in image_paths_with_indices
        }

        for i, future in enumerate(concurrent.futures.as_completed(future_to_idx)):
            try:
                idx, summary = future.result()
                summaries[idx] = summary
                logger.info(f"Completed {i+1}/{total} table summaries ({len(summary)} chars)")
            except Exception as e:
                idx = future_to_idx[future]
                logger.error(f"Failed to process table at index {idx}: {e}")
                summaries[idx] = ""

    return summaries


def batch_image_summaries_parallel(image_paths_with_indices: List[Tuple[int, str]]) -> dict:
    """
    Generate summaries for multiple document images in parallel.

    Args:
        image_paths_with_indices: List of (chunk_index, image_path) tuples

    Returns:
        Dict mapping chunk_index to summary text
    """
    if not image_paths_with_indices:
        return {}

    summaries = {}
    total = len(image_paths_with_indices)

    logger.info(f"Processing {total} document images in parallel (max_workers={VISION_BATCH_SIZE})")

    with concurrent.futures.ThreadPoolExecutor(max_workers=VISION_BATCH_SIZE) as executor:
        future_to_idx = {
            executor.submit(_process_single_image, item): item[0]
            for item in image_paths_with_indices
        }

        for i, future in enumerate(concurrent.futures.as_completed(future_to_idx)):
            try:
                idx, summary = future.result()
                summaries[idx] = summary
                logger.info(f"Completed {i+1}/{total} image summaries ({len(summary)} chars)")
            except Exception as e:
                idx = future_to_idx[future]
                logger.error(f"Failed to process image at index {idx}: {e}")
                summaries[idx] = ""

    return summaries


def batch_table_summaries(image_paths: list) -> list:
    """
    Generate summaries for multiple table images (sequential).
    Kept for backward compatibility.

    Args:
        image_paths: List of paths to table images

    Returns:
        List of summary texts
    """
    summaries = []
    for path in image_paths:
        if path:
            summary = generate_table_summary(path)
            summaries.append(summary)
        else:
            summaries.append("")
    return summaries
